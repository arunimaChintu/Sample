"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compile = compile;
exports.createCdsCompilerFacadeForRoot = createCdsCompilerFacadeForRoot;
exports.getCdsCompiler = getCdsCompiler;
exports.getCdsFiles = getCdsFiles;
exports.updateContentBasedOnReference = updateContentBasedOnReference;
const fs_1 = require("fs");
const path_1 = require("path");
const child_process_1 = require("child_process");
const url_1 = require("url");
const project_access_1 = require("@sap-ux/project-access");
const facade_1 = require("./facade");
const path_2 = require("./path");
async function compile(root, files, cache) {
    let cdsCompiler;
    try {
        const { compiler, home, cds } = await getCdsCompiler(root);
        cdsCompiler = compiler;
        const fileCache = [...(cache?.entries() || [])].reduce((acc, [uri, file]) => {
            const path = (0, path_2.pathFromUri)(uri);
            acc[path] = file;
            return acc;
        }, {});
        const env = cds.env.for('cds', root);
        const moduleLookupDirectories = env.cdsc?.moduleLookupDirectories ?? ['node_modules/'];
        const options = {
            fallbackParser: 'cds',
            attachValidNames: true,
            cdsHome: home,
            attachTokens: true,
            smart: {},
            messages: [],
            moduleLookupDirectories,
            ...env.cdsc
        };
        const compileModel = await cdsCompiler.$lsp.compile(files, root, options, fileCache);
        compileModel.compiler = { getArtifactName: cdsCompiler.$lsp.getArtifactName };
        return compileModel;
    }
    catch (error) {
        // compiler throws if there are syntax errors, but still attaches model which is sufficient for our use case
        if (!cdsCompiler || !(error instanceof cdsCompiler.CompilationError)) {
            throw error;
        }
        const { model } = error;
        model.compiler = { getArtifactName: cdsCompiler.$lsp.getArtifactName };
        return model;
    }
}
/**
 *
 * @param root Project root
 * @param files List of CDS model entrypoints
 * @param cache File content cache
 */
async function createCdsCompilerFacadeForRoot(root, files, cache) {
    const model = await compile(root, files, cache);
    return (0, facade_1.createCdsCompilerFacade)(model);
}
let globalCdsPathCache;
/**
 * Try to load global installation of @sap/cds, usually child of @sap/cds-dk.
 *
 * @returns - module @sap/cds from global installed @sap/cds-dk
 */
async function getGlobalCDSPath() {
    if (!globalCdsPathCache) {
        const versions = await getCdsVersionInfo();
        if (!versions.home) {
            throw Error('Can not find global installation of module @sap/cds, which should be part of @sap/cds-dk');
        }
        globalCdsPathCache = (0, path_1.normalize)((0, path_1.join)(versions.home, '..', '..', '..'));
    }
    return globalCdsPathCache;
}
/**
 * Get cds information, which includes versions and also the home path of cds module.
 *
 * @param [cwd] - optional folder in which cds --version should be executed
 * @returns - result of call 'cds --version'
 */
async function getCdsVersionInfo(cwd) {
    return new Promise((resolve, reject) => {
        let out = '';
        const cdsVersionInfo = (0, child_process_1.spawn)('cds', ['--version'], { cwd, shell: true });
        cdsVersionInfo.stdout.on('data', (data) => {
            out += data.toString();
        });
        cdsVersionInfo.on('close', () => {
            if (out) {
                const versions = {};
                for (const line of out.split('\n').filter((v) => v)) {
                    const [key, value] = line.split(': ');
                    versions[key] = value;
                }
                resolve(versions);
            }
            else {
                reject(new Error('Module path not found'));
            }
        });
        cdsVersionInfo.on('error', (error) => {
            reject(error);
        });
    });
}
async function loadCdsModule(projectRoot, searchRoot) {
    const module = await (0, project_access_1.loadModuleFromProject)(searchRoot, '@sap/cds');
    const cds = 'default' in module ? module.default : module;
    fixCdsGlobals(projectRoot, cds);
    return cds;
}
async function loadCdsCompilerModule(root) {
    const module = await (0, project_access_1.loadModuleFromProject)(root, '@sap/cds-compiler');
    return 'default' in module ? module.default : module;
}
/**
 * Get a reference to the compiler module (@sap/cds-compiler) installed in the Fiori elements project.
 * @param root - project root, where the package.json is
 */
async function getCdsCompiler(root) {
    try {
        // use project compiler
        const compiler = await loadCdsCompilerModule(root);
        const cds = await loadCdsModule(root, root);
        return { compiler, home: cds.home, cds };
    }
    catch (error) {
        try {
            const projectCdsDKRoot = (0, path_1.join)(root, 'node_modules', '@sap', 'cds-dk');
            // use project CDS DK if it exists otherwise use global
            const cdsDKRoot = (0, fs_1.existsSync)(projectCdsDKRoot) ? projectCdsDKRoot : await getGlobalCDSPath();
            const compiler = await loadCdsCompilerModule(cdsDKRoot);
            const cds = await loadCdsModule(root, cdsDKRoot);
            return { compiler, home: cds.home, cds };
        }
        catch (error) {
            if (error.code !== 'MODULE_NOT_FOUND') {
                throw error;
            }
            const errorMessage = 'Could not find CDS modules';
            throw new Error(errorMessage);
        }
    }
}
async function getCdsFiles(root, fileCache = new Map(), clearCache = false) {
    const { cds } = await getCdsCompiler(root);
    if (clearCache) {
        cds.resolve.cache = {};
    }
    const paths = getCapCustomPaths(root, cds);
    const roots = [(0, path_1.join)(root, paths.app), (0, path_1.join)(root, paths.srv), (0, path_1.join)(root, paths.db)];
    const resolvedFiles = cds.resolve(roots, {
        skipModelCache: true,
        root
    });
    const files = mergeCachedFiles(roots, fileCache, resolvedFiles);
    const model = await compile(root, files, fileCache);
    const facade = (0, facade_1.createCdsCompilerFacade)(model);
    return facade.getFileSequence();
}
function mergeCachedFiles(roots, fileCache, resolvedFiles) {
    if (fileCache.size === 0) {
        return resolvedFiles;
    }
    const cachedFiles = [...fileCache.keys()];
    const files = new Set();
    // in case the root files only reside in memfs
    // imitate cds.resolve to include those
    for (const root of roots) {
        const rootWithoutTrailingSlash = root.endsWith(path_1.sep) ? root.slice(0, -path_1.sep.length) : root;
        const rootURL = (0, url_1.pathToFileURL)(rootWithoutTrailingSlash).toString();
        const newFiles = cachedFiles.filter((uri) => (0, path_1.dirname)((0, path_2.pathFromUri)(uri)) === (0, path_2.pathFromUri)(rootURL) && /\.(csn|cds)$/.test(uri));
        const existingFiles = resolvedFiles.filter((file) => (0, path_1.dirname)(file) === rootWithoutTrailingSlash);
        for (const file of newFiles.map(path_2.pathFromUri)) {
            files.add(file);
        }
        for (const file of existingFiles) {
            files.add(file);
        }
    }
    return [...files.values()];
}
/**
 *  Parse the current contents and check if the reference exists or not.
 *
 * @param root - path of the CDS project.
 * @param currentContent - The current content of the file.
 * @param reference - The reference (path to the document ../abc/testFile).
 *
 * @returns Updated content if the reference needs to be added, otherwise returns undefined.
 */
async function updateContentBasedOnReference(root, currentContent, reference) {
    const { cds } = await getCdsCompiler(root);
    const annotationFileUsingStatement = `using from '${reference}';\n`;
    if (currentContent === '') {
        return annotationFileUsingStatement;
    }
    const parsed = cds.parse(currentContent);
    if (!Array.isArray(parsed?.requires) || parsed.requires.find((ref) => ref === reference) === undefined) {
        const separatorFromCurrentContent = currentContent.endsWith('\n') ? '' : '\n';
        return `${currentContent}${separatorFromCurrentContent}${annotationFileUsingStatement}`;
    }
    return undefined;
}
function fixCdsGlobals(root, cds) {
    // Fix when switching cds versions dynamically
    if (global) {
        global.cds = cds;
    }
}
function getCapCustomPaths(root, cds) {
    const paths = {
        app: 'app/',
        db: 'db/',
        srv: 'srv/'
    };
    // TODO: test if try catch is needed
    const env = cds.env.for('cds', root);
    if (env?.folders) {
        paths.app = env.folders.app;
        paths.srv = env.folders.srv;
        paths.db = env.folders.db;
    }
    return paths;
}
//# sourceMappingURL=compile.js.map