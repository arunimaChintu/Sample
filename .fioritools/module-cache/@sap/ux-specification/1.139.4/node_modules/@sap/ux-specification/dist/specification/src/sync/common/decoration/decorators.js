"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validity = exports.validityMetadataKey = exports.getDescriptionSrcURL = exports.descriptionSrcURL = exports.descriptionUrlMetadataKey = exports.getPageLayoutInformation = exports.getChildId = exports.childId = exports.pageLayoutInformation = exports.syncRule = exports.reflectMetadataKey = void 0;
exports.getReflectMetadata = getReflectMetadata;
exports.getReflectTypeMetadata = getReflectTypeMetadata;
exports.getTextForDeprecated = getTextForDeprecated;
require("reflect-metadata");
exports.reflectMetadataKey = Symbol('specificationMetadataKey');
const syncRule = (propSpec) => {
    return Reflect.metadata(exports.reflectMetadataKey, propSpec);
};
exports.syncRule = syncRule;
/**
 * Retrieves the metadata associated with a specific property of a target object.
 *
 * @param target - The object containing the property.
 * @param propertyName - The name of the property whose metadata is to be retrieved.
 * @returns The metadata of the property, or undefined if no metadata is found.
 */
function getReflectMetadata(target, propertyName) {
    let rule;
    if (target) {
        rule = Reflect.getMetadata(exports.reflectMetadataKey, target, propertyName);
    }
    return rule;
}
/**
 * Return the sync rule a given class has been decorated with.
 *
 * @param cls - The constructor of the class that provides the sync rule
 * @returns the sync rule (if it exists)
 */
function getReflectTypeMetadata(cls) {
    let rule;
    if (cls) {
        rule = Reflect.getMetadata(exports.reflectMetadataKey, cls);
    }
    return rule;
}
const pageLayoutInformation = (pageInfo) => (constructor) => {
    constructor.prototype.pageLayoutInformation = pageInfo;
};
exports.pageLayoutInformation = pageLayoutInformation;
const childIdKey = Symbol('childId');
const childId = (id) => {
    return Reflect.metadata(childIdKey, id);
};
exports.childId = childId;
const getChildId = (target, propertyName) => {
    return Reflect.getMetadata(childIdKey, target, propertyName);
};
exports.getChildId = getChildId;
const getPageLayoutInformation = (target) => {
    return Object.getPrototypeOf(target).pageLayoutInformation;
};
exports.getPageLayoutInformation = getPageLayoutInformation;
/*
 * Metadata describing the documentation link
 */
exports.descriptionUrlMetadataKey = Symbol('descriptionSrcURL');
const descriptionSrcURL = (id) => {
    return Reflect.metadata(exports.descriptionUrlMetadataKey, id);
};
exports.descriptionSrcURL = descriptionSrcURL;
const getDescriptionSrcURL = (target, propertyName) => {
    return Reflect.getMetadata(exports.descriptionUrlMetadataKey, target, propertyName);
};
exports.getDescriptionSrcURL = getDescriptionSrcURL;
/*
 * Validity decorator and functions for it
 */
exports.validityMetadataKey = Symbol('validityMetadataKey');
const validity = (propSpec) => {
    return Reflect.metadata(exports.validityMetadataKey, propSpec);
};
exports.validity = validity;
/**
 * Generates a deprecation message for a given key, optionally including additional validity information.
 *
 * @param key - The key or property name that is deprecated.
 * @param validityInformation - Optional validity information providing details about the deprecation.
 * @returns A string containing the deprecation message.
 */
function getTextForDeprecated(key, validityInformation) {
    let text = `${key} is deprecated`;
    if (validityInformation && validityInformation.deprecated) {
        text = validityInformation.deprecated.since ? `${text} since ${validityInformation.deprecated.since}` : text;
        text = validityInformation.deprecated.text ? `${text}. ${validityInformation.deprecated.text}` : text;
    }
    return text;
}
//# sourceMappingURL=decorators.js.map