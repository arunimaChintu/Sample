"use strict";
/**
 * @file This file hosts the entry point for generating the schema of a v2 List Report Page.
 * The schema is yet incomplete and is normally ignored by the runtime.
 * For manual tests it can be made active by switching useGenericSchemaHandling in pageAccess.ts to true.
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListReportNew = void 0;
const Table_1 = require("@sap/ux-specification-types/src/v2/controls/Table");
const ux_specification_types_1 = require("@sap/ux-specification-types");
const decorators_1 = require("../../../common/decoration/decorators");
const v2_1 = require("@sap/ux-specification-types/src/v2");
const utils_1 = require("../../utils");
const ListHeader_1 = require("../controls/ListHeader");
const FilterBar_1 = require("../controls/FilterBar");
const Action_1 = require("../controls/Action");
const utils_2 = require("../../generate/utils");
/**
 * This function should return the information whether the given entity type is analytical.
 * Unfortunately this is currently impossible due to missing information provided by the annotation api.
 * As soon as the annotation api has been enhanced accordingly, this function should be enhanced.
 *
 * @param entityTypeDefinition - the entity type to be checked
 * @returns true if the entity type is analytical, false otherwise
 */
function isTypeAnalytical(entityTypeDefinition) {
    return false; // todo: enhance
}
/**
 * Returns the default table type used for tables for the given entity type (i.e. the table type which will be used by Fiori Elements if no manifest setting for the table type is available).
 *
 * @param entityTypeDefinition - the entity type for which the table is created
 * @returns the default table type for the given entity type
 */
function getDefaultTableType(entityTypeDefinition) {
    const isAnalytical = isTypeAnalytical(entityTypeDefinition);
    return isAnalytical ? Table_1.TableTypeV2.AnalyticalTable : Table_1.TableTypeV2.ResponsiveTable;
}
// ListReportNew
let ListReportNew = class ListReportNew {
};
exports.ListReportNew = ListReportNew;
__decorate([
    (0, decorators_1.syncRule)({
        flex: {
            controlType: () => ux_specification_types_1.ControlType.DynamicPage
        },
        processingRuleAdapter(processingRule) {
            processingRule.controlId = 'page';
        }
    })
], ListReportNew.prototype, "fitContent", void 0);
__decorate([
    (0, decorators_1.syncRule)({
        processingRuleAdapter(processingRule) {
            processingRule.element[ux_specification_types_1.SchemaTag.propertyIndex] = 0;
            processingRule.referenceAdaptation = {
                syncRuleProvider: ListHeader_1.ListHeader
            };
        }
    })
], ListReportNew.prototype, "header", void 0);
__decorate([
    (0, decorators_1.syncRule)({
        processingRuleAdapter(processingRule, schemaHandlingParams) {
            const lRSchemaHandlingParams = schemaHandlingParams.specificParams;
            if (lRSchemaHandlingParams.settings?.isWorklist) {
                // no filterbar shown in worklist apps
                delete processingRule.element;
                return;
            }
            processingRule.element[ux_specification_types_1.SchemaTag.propertyIndex] = 1;
            processingRule.referenceAdaptation = {
                syncRuleProvider: FilterBar_1.ListReportFilterBar
            };
        }
    })
], ListReportNew.prototype, "filterBar", void 0);
__decorate([
    (0, decorators_1.syncRule)({
        processingRuleAdapter(processingRule, schemaHandlingParams) {
            const lRSchemaHandlingParams = schemaHandlingParams.specificParams;
            processingRule.element[ux_specification_types_1.SchemaTag.propertyIndex] = 3;
            (0, Action_1.adaptProcessingRuleForToolbar)(processingRule, utils_2.DataFieldTarget.Footer, lRSchemaHandlingParams.lineItemInfo?.dataFieldInfos);
        }
    })
], ListReportNew.prototype, "footer", void 0);
exports.ListReportNew = ListReportNew = __decorate([
    (0, decorators_1.pageLayoutInformation)({
        id: v2_1.SAPUI5_VIEW_EXTENSION_LIST_REPORT,
        pageId: v2_1.FE_TEMPLATE_V2_LIST_REPORT
    }),
    (0, decorators_1.syncRule)({
        processingRuleAdapter(processingRule, schemaHandlingParams, generateParameters) {
            const { entityType, uIAnnotations } = (0, utils_2.getUIAnnotationForEntitySet)(generateParameters); // would log an error in case these entities are missing
            const manifestPathToPageSettings = (0, utils_1.getManifestPathToPageSettings)(schemaHandlingParams.pageInfo.pagePath);
            const { parent: pageSettings } = (0, utils_1.getManifestPropertyByPath)(generateParameters.manifest, manifestPathToPageSettings);
            const settings = pageSettings;
            const tableSettings = settings?.tableSettings;
            const tableType = tableSettings?.['type'] || settings?.tableType || getDefaultTableType(entityType);
            const lineItemAnnotation = (0, utils_2.getLineItemAnnotation)(uIAnnotations, settings, generateParameters.logger);
            let lineItemInfo;
            if (lineItemAnnotation) {
                const lineItemName = lineItemAnnotation.term + (lineItemAnnotation.qualifier ? `#${lineItemAnnotation.qualifier}` : '');
                const accessor = lineItemName.replace(ux_specification_types_1.UIVOCABULARYDOT, '');
                const lineItemDefinition = uIAnnotations[accessor];
                lineItemInfo = (0, utils_2.getLineItemInfo)(lineItemName, lineItemDefinition, entityType, tableType, generateParameters, false);
            }
            const specificParams = {
                settings,
                entityType,
                uIAnnotations,
                tableType,
                lineItemInfo
            };
            // Further processing will be done on level of properties of this class
            processingRule.referenceAdaptation = {
                specificParams
            };
        }
    })
], ListReportNew);
//# sourceMappingURL=ListReportNew.js.map