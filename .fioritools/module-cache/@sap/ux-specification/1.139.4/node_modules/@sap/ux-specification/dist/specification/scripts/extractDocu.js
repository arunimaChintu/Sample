"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This script extracts all existing documentation (i.e. descriptions) from the generic schemas of a certain OData version (V2 or V4).
 * All descriptions are collected in an Excel sheet that you afterwards can find under dist/documentation: it is named Specificationv2.xslx or Specificationv4.xslx, depending on the chosen version.
 * You can find one worksheet for each generic schema file.
 *
 * The script expects that you supply an argument --version with either v2 or v4.
 * You can also start it from one of the debugger scripts named in launch.json: "Extract V2 documentation" or "Extract V4 documentation".
 */
const ux_specification_types_1 = require("@sap/ux-specification-types");
const path_1 = require("path");
const fs_1 = require("fs");
const excel = __importStar(require("excel4node"));
const common_1 = require("../src/sync/common");
/**
 * Handles reference ($ref) within the schema, finds the corresponding definition.
 *
 * @param schema - Object representing the whole generic schema
 * @param reference - Content for the $ref property
 * @param output - Array of descriptions with assigned hierarchy elements, all separated by ';' (csv like)
 * @param parsedTypes - Set of (names of) already parsed types. Will be updated by this function.
 * @param definition - The current hierarchy element (list of path parts separated by ';')
 * @param description - The description of the current hierarchy element
 * @param additionalMetadata - Additional information about the current hierarchy element, separated by ';'
 * @param descriptionSrcUrl - The source URL for the description of the current hierarchy element
 */
function dereference(schema, reference, output, parsedTypes, definition, description, additionalMetadata, descriptionSrcUrl) {
    const currentDefinition = (0, common_1.getDefinitionKey)(reference);
    if (parsedTypes.has(currentDefinition)) {
        return; // Do not parse types that have already been parsed (avoid infinite loops in case of recursive references)
    }
    parsedTypes.add(currentDefinition);
    try {
        parseSchema(schema, schema['definitions'][currentDefinition], output, parsedTypes, definition, description, additionalMetadata, descriptionSrcUrl);
    }
    catch (error) {
        console.log(error);
    }
}
/**
 * Handles one property of a sub-schema.
 *
 * @param schema - Object representing the whole generic schema
 * @param subSchema - Object representing the current sub-structure of the schema
 * @param property - Name of the property within the subSchema
 * @param output  - Array of descriptions with assigned hierarchy elements, all separated by ';' (csv like)
 * @param parsedTypes - Set of (names of) already parsed types. Will be updated by this function.
 * @param definition - The current hierarchy element (list of path parts separated by ';')
 */
function processElement(schema, subSchema, property, output, parsedTypes, definition) {
    const element = subSchema[property];
    let additionalMetadata;
    function addMetadata() {
        if (additionalMetadata) {
            output.push(definition +
                ';' +
                `TYPE_${element['type']}` +
                additionalMetadata +
                ';' +
                `DESC_${element['description']}` +
                ';' +
                `URL_${element['descriptionSrcURL']}`);
        }
        else {
            output.push(definition +
                ';' +
                `TYPE_${element['type']}` +
                ';' +
                `DESC_${element['description']}` +
                ';' +
                `URL_${element['descriptionSrcURL']}`);
        }
    }
    // Ignored properties
    if (['$schema', 'id', 'pages', 'home', 'custom', '1', '2', '3', '4', '5', '6', '7', '8', '9'].includes(property)) {
        return;
    }
    const property2write = property === '^[0-9]+$' ? 'Instance (key = number)' : property;
    definition = definition ? definition + ';' + property2write : property2write;
    if (property === 'columns') {
        definition = definition + ';columnId';
    }
    if (property === 'sections') {
        definition = definition + ';sectionId';
    }
    if (property === 'cards') {
        definition = definition + ';cardKey';
    }
    if (property === 'subsections') {
        definition = definition + ';subsectionId';
    }
    if (element['artifactType']) {
        additionalMetadata = `;ARTIFACT_${element['artifactType']}`;
    }
    if (element['controlType']) {
        additionalMetadata += `;CONTROL_${element['controlType']}`;
    }
    if (element['description']) {
        if (element['$ref']) {
            dereference(schema, element['$ref'], output, parsedTypes, definition, element['description'], additionalMetadata);
            return;
        }
        else if (element['anyOf']) {
            handleAnyOf(schema, element['anyOf'], output, parsedTypes, definition, element['description'], element, additionalMetadata);
            return;
        }
        if (element['type'] && element['items']) {
            const reference = element['items']['$ref'] || (element['items'][0] && element['items'][0]['$ref']);
            if (reference) {
                dereference(schema, reference, output, parsedTypes, definition, element['description'], additionalMetadata);
            }
            else {
                addMetadata();
            }
            return;
        }
        addMetadata();
    }
    // Temporary as Description is not maintained for some properties - description should be added
    if (!element['description'] && element['type']) {
        if (additionalMetadata) {
            output.push(definition + ';' + `TYPE_${element['type']}` + additionalMetadata);
        }
        else {
            output.push(definition + ';' + `TYPE_${element['type']}`);
        }
    }
    if (element['$ref']) {
        dereference(schema, element['$ref'], output, parsedTypes, definition);
    }
    else {
        parseSchema(schema, element, output, parsedTypes, definition);
    }
}
/**
 * Special handling of anyOf elements of a JSON schema.
 *
 * @param schema - Object representing the whole generic schema
 * @param anyOfSchema - Object representing the current sub-structure of the schema
 * @param output - Array of descriptions with assigned hierarchy elements, all separated by ';' (csv like)
 * @param parsedTypes - Set of (names of) already parsed types. Will be updated by this function.
 * @param definition - The current hierarchy element (list of path parts separated by ';')
 * @param description - The description of the current hierarchy element
 * @param element - Object representing the sub-structure of the current hierarchy element
 * @param additionalMetadata - Additional information about the current hierarchy element, separated by ';' (e.g. artifactType)
 */
function handleAnyOf(schema, anyOfSchema, output, parsedTypes, definition, description, element, additionalMetadata) {
    for (let index = 0; index < anyOfSchema.length; index++) {
        const anyOfSchemaElement = anyOfSchema[index];
        if (element?.['pattern'] && anyOfSchemaElement['type'] === 'string') {
            return;
        }
        if (Object.keys(anyOfSchemaElement)[0] === '$ref') {
            dereference(schema, anyOfSchemaElement['$ref'], output, parsedTypes, definition, description, additionalMetadata);
        }
        else {
            parseSchema(schema, anyOfSchemaElement, output, parsedTypes, definition, description, additionalMetadata);
        }
    }
}
/**
 * Parses a sub-structure of the schema.
 *
 * @param schema - Object representing the whole generic schema
 * @param subSchema - Object representing the current sub-structure of the schema
 * @param output - Array of descriptions with assigned hierarchy elements, all separated by ';' (csv like)
 * @param parsedTypes - Set of (names of) already parsed types. Will be updated by this function.
 * @param definition - The current hierarchy element (list of path parts separated by ';')
 * @param description - The description of the current hierarchy element
 * @param additionalMetadata - Additional information about the current hierarchy element, separated by ';' (e.g. artifactType)
 * @param descriptionSrcUrl - The source URL for the description of the current schema element
 */
function parseSchema(schema, subSchema, output, parsedTypes = new Set(), definition, description, additionalMetadata, descriptionSrcUrl) {
    if (Object.keys(subSchema) && Object.keys(subSchema)[0] === 'anyOf') {
        handleAnyOf(schema, subSchema['anyOf'], output, parsedTypes, definition);
        return;
    }
    for (const property in subSchema['properties']) {
        if (property === '$ref') {
            dereference(schema, subSchema['properties']['$ref'], output, parsedTypes, definition, descriptionSrcUrl);
        }
        else if (property === 'anyOf') {
            handleAnyOf(schema, subSchema['properties']['anyOf'], output, parsedTypes, definition, descriptionSrcUrl);
        }
        else {
            processElement(schema, subSchema['properties'], property, output, parsedTypes, definition);
        }
    }
    for (const property in subSchema['patternProperties']) {
        if (property === '$ref') {
            dereference(schema, subSchema['patternProperties']['$ref'], output, parsedTypes, definition);
        }
        else if (property === 'anyOf') {
            handleAnyOf(schema, subSchema['patternProperties']['anyOf'], output, parsedTypes, definition);
        }
        else {
            processElement(schema, subSchema['patternProperties'], property, output, parsedTypes, definition);
        }
    }
    for (const property in subSchema['additionalProperties']) {
        if (property === '$ref') {
            dereference(schema, subSchema['additionalProperties']['$ref'], output, parsedTypes, definition);
        }
        else if (property === 'anyOf') {
            handleAnyOf(schema, subSchema['additionalProperties']['anyOf'], output, parsedTypes, definition);
        }
        else {
            processElement(schema, subSchema['additionalProperties'], property, output, parsedTypes, definition);
        }
    }
    if (subSchema['enum'] && description) {
        if (additionalMetadata) {
            output.push(definition +
                ';' +
                `TYPE_${[subSchema['enum'].join('|')]}` +
                additionalMetadata +
                ';' +
                `DESC_${description}` +
                ';' +
                `URL_${descriptionSrcUrl}`);
        }
        else {
            output.push(definition +
                ';' +
                `TYPE_${[subSchema['enum'].join('|')]}` +
                ';' +
                `DESC_${description}` +
                ';' +
                `URL_${descriptionSrcUrl}`);
        }
    }
    else if (subSchema['type'] && description) {
        if (additionalMetadata) {
            output.push(definition +
                ';' +
                `TYPE_${subSchema['type']}` +
                additionalMetadata +
                ';' +
                `DESC_${description}` +
                ';' +
                `URL_${descriptionSrcUrl}`);
        }
        else {
            output.push(definition +
                ';' +
                `TYPE_${subSchema['type']}` +
                ';' +
                `DESC_${description}` +
                ';' +
                `URL_${descriptionSrcUrl}`);
        }
    }
}
/**
 * Fills an excel4node workbook based on csv like information.
 *
 * @param workbook - Excel workbook (excel4node format)
 * @param output - Array of descriptions with assigned hierarchy elements, all separated by ';' (csv like)
 * @param file - file name of the original schema
 */
function writeToExcel(workbook, output, file) {
    //filter output to remove duplicated lines due to different table types (anyOf)
    output = output.filter((e, i, a) => a.indexOf(e) === i);
    const sheetName = file.split('.')[0];
    const worksheet = workbook.addWorksheet(sheetName);
    worksheet.headerFooter = { evenHeader: output[0] };
    // Create a reusable style
    const style = workbook.createStyle({
        font: {
            //color: '#800000',
            size: 12
        },
        numberFormat: '$#,##0.00; ($#,##0.00); -'
    });
    for (let rowIndex = 1; rowIndex < output.length; rowIndex++) {
        const element = output[rowIndex];
        const cellArray = element.split(';');
        for (let cellIndex = 0; cellIndex < cellArray.length; cellIndex++) {
            let cell = cellArray[cellIndex];
            // skip writing undefined urls into sheet
            if (cell.includes('URL_undefined')) {
                continue;
            }
            // remove the prefix for better readability
            if (cell.includes('DESC_') || cell.includes('URL_')) {
                cell = cell.split('_')[1];
            }
            worksheet
                .cell(rowIndex, cellIndex + 1)
                .string(cell)
                .style(style);
        }
    }
}
/**
 * Creates a tree data structure from the given output and metadata.
 *
 * @param output - Array of descriptions with assigned hierarchy elements, all separated by ';' (csv-like).
 * @param floorPlan - The name of the floor plan being processed.
 * @param odataVersion - The OData version (e.g., "v2" or "v4").
 * @param specVersion - The specification version of the schema.
 * @returns A TreeData object representing the hierarchical structure of the schema.
 */
function createTreeData(output, floorPlan, odataVersion, specVersion) {
    let root;
    const treeData = {
        name: floorPlan,
        description: 'SAP Fiori elements for OData ' +
            odataVersion.toUpperCase() +
            '<br>@sap/ux-specification version ' +
            specVersion,
        type: 'schema',
        children: []
    };
    /**
     * Determines the type of metadata based on the provided string.
     *
     * @param string - The input string to analyze.
     * @returns The type of metadata as a string (e.g., 'artifact', 'control', 'url', or 'description').
     */
    function find(string) {
        if (string.includes('ARTIFACT_')) {
            return 'artifact';
        }
        else if (string.includes('CONTROL_')) {
            return 'control';
        }
        else if (string.includes('URL_')) {
            return 'url';
        }
        else if (string.includes('DESC_')) {
            return 'description';
        }
    }
    /**
     * Adds a key-value pair to the tree structure or navigates to an existing node.
     *
     * @param element - The current element being processed.
     * @param index - The index of the current element in the array.
     * @param elementsArray - The array of elements representing the hierarchy.
     * @returns A boolean indicating whether the element was added or navigated to.
     */
    function addKeyValue(element, index, elementsArray) {
        if (element.includes('TYPE_')) {
            root.type = element.split('_')[1];
            for (let i = index + 1; i < elementsArray.length; i++) {
                let match;
                if (elementsArray[i] !== '') {
                    match = find(elementsArray[i]);
                }
                switch (match) {
                    case 'artifact':
                        if (elementsArray[i].split('_')[1] === 'FlexChange') {
                            root.artifact = 'UI5 flexibility';
                        }
                        else {
                            root.artifact = elementsArray[i].split('_')[1];
                        }
                        break;
                    case 'control':
                        root.control = elementsArray[i].split('_')[1];
                        break;
                    case 'url':
                        break;
                    default:
                        root.description = elementsArray[i].split('_')[1];
                }
            }
            return false;
        }
        else {
            for (let i = 0; i < root.children.length; i++) {
                if (element === root.children[i].name) {
                    root = root.children[i];
                    return true;
                }
            }
            root.children.push({
                name: element,
                children: []
            });
            root = root.children[root.children.length - 1];
            return true;
        }
    }
    output.forEach((line) => {
        const elements = line.split(';');
        root = treeData;
        elements.every(addKeyValue);
    });
    return treeData;
}
/**
 * Creates an SVG icon representation for the given floor plan.
 *
 * @param floorPlan - The name of the floor plan for which the SVG icon is generated.
 * @returns A string containing the SVG path data for the floor plan icon, or undefined if no matching icon is found.
 */
function createSVGIcon(floorPlan) {
    let svgFormat = `<path fill-rule="evenodd" clip-rule="evenodd" fill="var(--vscode-icon-foreground)"`;
    const svgPathALP = `d="M9 13V14H6V13H9ZM5 13V14H2V13H5ZM13 13V14H10V13H13ZM9 11V12H6V11H9ZM5 11V12H2V11H5ZM13 11V12H10V11H13ZM5 9V10H2V9H5ZM9 9V10H6V9H9ZM13 9V10H10V9H13ZM3.986 1.998V6.024H1.965V1.998H3.986ZM6.99 4.01V6.01H4.99V4.01H6.99ZM10.008 3.019V6.01H8.008V3.019H10.008ZM13.005 1.998V6.011H11.005V1.998H13.005ZM1 14.988H14.988V7.995H1V14.988ZM1.001 6.994H14.989V1H1.001V6.994ZM1.00169 0C0.449309 0 0 0.448336 0 1.00075V14.9992C0 15.5517 0.449309 16 1.00169 16H14.9993C15.5517 16 16 15.5517 16 14.9992V1.00075C16 0.448336 15.5517 0 14.9993 0H1.00169Z"`;
    const svgPathLR = `d="M5 3.0028H2V2.0048H5V3.0028ZM6.0044 3.0028H9.0044V2.0048H6.0044V3.0028ZM10.0014 3.0028H13.0014V2.0048H10.0014V3.0028ZM1 14.993L0.997 4.995H14.988V14.988L1 14.993ZM14.988 0.995V3.994H0.996L0.995 1L14.988 0.995ZM14 7H10V6H14V7ZM11 9.0028H14V8.0048H11V9.0028ZM14 11H10V10H14V11ZM14 13.0028H11V12.0048H14V13.0028ZM6 12.999H9V12.001H6V12.999ZM9 10.999H6V10.001H9V10.999ZM6 8.999H9V8.001H6V8.999ZM9 6.999H6V6.001H9V6.999ZM2 12.999H5V12.001H2V12.999ZM5 11.0028H2V10.0048H5V11.0028ZM2 9.0028H5V8.0048H2V9.0028ZM5 6.999H2V6.001H5V6.999ZM14.993 0H0.995C0.446 0 0 0.446 0 0.995V14.993C0 15.542 0.446 15.988 0.995 15.988H14.993C15.542 15.988 15.988 15.542 15.988 14.993V0.995C15.988 0.446 15.542 0 14.993 0Z"`;
    const svgPathOP = `d="M9 13V14H6V13H9ZM9 11V12H6V11H9ZM13 9V10H10V9H13ZM9 9V10H6V9H9ZM5 9V10H2V9H5ZM14.989 7.996L14.988 14.989H1L1.001 7.996H14.989ZM3.998 2C5.1 2 5.996 2.896 5.996 3.998C5.996 5.1 5.1 5.996 3.998 5.996C2.896 5.996 2 5.1 2 3.998C2 2.896 2.896 2 3.998 2ZM14 4.0046V5.0046H8V4.0046H14ZM3.998 3C3.447 3 3 3.447 3 3.998C3 4.549 3.447 4.996 3.998 4.996C4.549 4.996 4.996 4.549 4.996 3.998C4.996 3.447 4.549 3 3.998 3ZM12.002 2V3H8V2H12.002ZM14.989 1.001V6.995H1.001V1L14.989 1.001ZM14.989 0H1.001C0.449 0 0 0.449 0 1.001V14.989C0 15.541 0.449 15.989 1.001 15.989H14.989C15.541 15.989 15.989 15.541 15.989 14.989V1.001C15.989 0.488429 15.6027 0.0646684 15.1056 0.00674636L14.989 0Z"`;
    const svgPathOVP = `d="M14.988 15.488V14.988H14.989L14.988 15.488ZM14.988 14.988H1V1H14.988V14.988ZM14.988 0H1C0.448 0 0 0.448 0 1V14.988C0 15.54 0.448 15.988 1 15.988H14.988C15.54 15.988 15.988 15.54 15.988 14.988V1C15.988 0.448 15.54 0 14.988 0ZM2.9917 7.037H7.0147V3.014H2.9917V7.037ZM7.5147 2.013H2.4907C2.2147 2.013 1.9907 2.237 1.9907 2.513V7.537C1.9907 7.813 2.2147 8.037 2.4907 8.037H7.5147C7.7907 8.037 8.0147 7.813 8.0147 7.537V2.513C8.0147 2.237 7.7907 2.013 7.5147 2.013ZM7.0147 13.014H2.9917V10.034H7.0147V13.014ZM2.4907 9.034H7.5147C7.7907 9.034 8.0147 9.258 8.0147 9.534V13.514C8.0147 13.791 7.7907 14.014 7.5147 14.014H2.4907C2.2147 14.014 1.9907 13.791 1.9907 13.514V9.534C1.9907 9.258 2.2147 9.034 2.4907 9.034ZM9.9847 9.034H13.0217V3.013H9.9847V9.034ZM13.5217 2.013H9.4847C9.2087 2.013 8.9847 2.237 8.9847 2.513V9.534C8.9847 9.81 9.2087 10.034 9.4847 10.034H13.5217C13.7987 10.034 14.0217 9.81 14.0217 9.534V2.513C14.0217 2.237 13.7987 2.013 13.5217 2.013ZM13.0217 13.006H9.9847V12.021H13.0217V13.006ZM9.4847 11.02H13.5217C13.7987 11.02 14.0217 11.244 14.0217 11.52V13.506C14.0217 13.782 13.7987 14.006 13.5217 14.006H9.4847C9.2087 14.006 8.9847 13.782 8.9847 13.506V11.52C8.9847 11.244 9.2087 11.02 9.4847 11.02Z"`;
    const name = floorPlan.toLowerCase();
    if (name.includes('analytical')) {
        svgFormat += svgPathALP + `/>`;
    }
    else if (name.includes('listreport')) {
        svgFormat += svgPathLR + `/>`;
    }
    else if (name.includes('objectpage')) {
        svgFormat += svgPathOP + `/>`;
    }
    else if (name.includes('overviewpage')) {
        svgFormat += svgPathOVP + `/>`;
    }
    else if (name.includes('app')) {
        svgFormat +=
            `d="M3 3H13V4L14 4.5V3C14 2.44771 13.5523 2 13 2H3C2.44772 2 2 2.44771 2 3V13C2 13.5523 2.44772 14 3 14H4L3.5 13H3V6H6.79999L7 5H3V3Z"/>` +
                `<path fill-rule="evenodd" clip-rule="evenodd" fill="var(--vscode-icon-foreground)" d="M8.28944 4.55013C8.08524 4.54527 7.90338 4.67855 7.84651 4.87473C7.72432 5.2963 7.6087 5.85047 7.57817 6.50159C7.55755 6.90136 7.57389 7.26774 7.6084 7.59183C7.14124 7.51867 6.56355 7.49155 5.9202 7.60389C5.53848 7.66768 5.21146 7.7753 4.94353 7.87882C4.77595 7.94356 4.66294 8.10177 4.65604 8.28128C4.64316 8.61616 4.66223 9.20756 4.94215 9.87157L4.9427 9.87287C5.10582 10.2564 5.31634 10.5678 5.52562 10.8133C5.04431 11.475 4.72674 12.3015 4.65154 13.2092C4.63368 13.4249 4.77178 13.6227 4.98034 13.6802C5.50707 13.8255 6.24965 13.9717 7.14457 13.9473C8.41699 13.9108 9.40314 13.5455 9.98776 13.2715C10.1669 13.1875 10.2702 12.9963 10.2422 12.8004C10.2245 12.6761 10.2147 12.5012 10.2427 12.2906C10.279 12.0236 10.3694 11.8204 10.4419 11.6889C10.5324 11.5249 10.5118 11.322 10.3902 11.1795C10.2686 11.037 10.0714 10.9847 9.89519 11.0482C9.57944 11.1621 9.05531 11.3087 8.4241 11.2734C7.97335 11.2478 7.62017 11.1448 7.49082 11.1017C7.25504 11.0231 7.0002 11.1506 6.92161 11.3863C6.84301 11.6221 6.97044 11.8769 7.20621 11.9555C7.38503 12.0151 7.81976 12.1405 8.37342 12.172C8.73572 12.1922 9.06814 12.165 9.35869 12.1164C9.35591 12.1341 9.35316 12.153 9.35071 12.1711C9.33105 12.3185 9.32406 12.4555 9.32528 12.5797C8.80396 12.7935 8.04887 13.0209 7.11923 13.0477C6.5294 13.0637 6.01468 12.9951 5.5973 12.9053C5.72067 12.2067 6.01582 11.6045 6.41153 11.1414C6.42714 11.1286 6.44207 11.1147 6.45621 11.0995C6.47511 11.0793 6.49179 11.0577 6.50624 11.0352C6.97818 10.5288 7.57578 10.2101 8.19028 10.1441C9.38946 10.0141 10.3214 10.869 10.4939 11.0359C10.6725 11.2087 10.9574 11.2041 11.1302 11.0255C11.3031 10.8469 11.2984 10.562 11.1198 10.3892C10.9385 10.2137 9.73609 9.07121 8.09326 9.24935C7.36648 9.32751 6.6927 9.647 6.13655 10.1389C6.00352 9.9691 5.87453 9.7641 5.7712 9.52132C5.62761 9.18046 5.57487 8.86423 5.559 8.61555C5.71656 8.56568 5.88655 8.52193 6.06996 8.49136L6.07355 8.49074C6.89742 8.34656 7.59518 8.48011 8.02817 8.60531C8.17937 8.64903 8.34242 8.61058 8.45815 8.50392C8.57388 8.39725 8.62547 8.23788 8.5942 8.08362C8.51409 7.68841 8.4452 7.16228 8.47702 6.54698L8.47713 6.54474C8.49589 6.14338 8.55165 5.7845 8.62004 5.47956C9.00004 5.53292 9.59947 5.68299 10.1451 6.1105C9.92078 6.41779 9.64801 6.86697 9.4904 7.41311C9.42847 7.62214 9.39189 7.82094 9.36997 7.97205C9.35889 8.04841 9.35139 8.11379 9.34627 8.16346C9.34372 8.18828 9.34176 8.2091 9.34032 8.22477L9.33859 8.24355L9.3381 8.24876C9.31065 8.49577 9.48864 8.71826 9.73565 8.74571C9.98266 8.77315 10.2051 8.59516 10.2326 8.34815C10.2335 8.3401 10.2345 8.32891 10.2359 8.31491C10.2458 8.21004 10.2705 7.94769 10.3537 7.66752L10.3547 7.66398C10.4535 7.321 10.6151 7.0216 10.7701 6.78769C10.9839 7.10354 11.2229 7.58086 11.2592 8.19734C11.274 8.49701 11.2593 8.96542 11.0381 9.53348C11.0178 9.58553 11.0075 9.6409 11.0075 9.69676C11.0075 10.008 11.0845 10.333 11.3818 10.4816C11.5368 10.5592 11.6889 10.5524 11.8033 10.5236C11.9034 10.4983 11.9905 10.4521 12.0438 10.4228C12.0784 10.4037 12.1094 10.386 12.1386 10.3692C12.219 10.3231 12.2867 10.2843 12.3824 10.2464L12.3885 10.2438C12.5093 10.1938 12.662 10.1525 12.8499 10.1525C13.0204 10.1525 13.1762 10.0562 13.2524 9.90371C13.4973 9.414 13.8461 8.56346 13.932 7.45511C14.0177 6.3884 13.8215 5.5248 13.6626 5.00534C13.615 4.84985 13.4873 4.73211 13.3284 4.69736C13.1079 4.64912 12.7116 4.59308 12.2434 4.6979C11.9079 4.77323 11.6521 4.89716 11.477 5.0022C11.2639 5.13007 11.1948 5.40648 11.3227 5.61959C11.4505 5.83271 11.727 5.90181 11.9401 5.77394C12.0504 5.70778 12.2169 5.62626 12.4406 5.57604C12.6027 5.53978 12.7522 5.53387 12.8781 5.54114C12.9929 5.99437 13.0954 6.63079 13.0348 7.38363L13.0347 7.38501C12.9726 8.18807 12.7503 8.83523 12.5554 9.27279C12.3596 9.30016 12.1899 9.35224 12.0475 9.41094L12.0214 9.42157C12.164 8.89507 12.1732 8.45471 12.158 8.15055L12.1578 8.14688C12.086 6.91328 11.4078 6.10954 11.1726 5.84339C11.1665 5.83646 11.1601 5.82972 11.1536 5.82318C11.1491 5.81872 11.1438 5.81292 11.1315 5.79923L11.1288 5.79622C11.1192 5.78543 11.1017 5.76577 11.0826 5.74653C9.98289 4.60991 8.55395 4.55643 8.28944 4.55013Z"/>`;
    }
    else {
        return undefined;
    }
    return svgFormat;
}
/**
 * Generates an HTML file based on the given output and metadata.
 *
 * @param output - Array of descriptions with assigned hierarchy elements, all separated by ';' (csv-like).
 * @param file - The name of the file being processed.
 * @param odataVersion - The OData version (e.g., "v2" or "v4").
 */
async function generateHTMLFormat(output, file, odataVersion) {
    //filter output to remove duplicated lines due to different table types (anyOf)
    output = output.filter((e, i, a) => a.indexOf(e) === i);
    output.shift();
    const nameFloorPlan = file.split('.')[0].replace(/Config/g, '');
    const rootName = __dirname.slice(0, __dirname.lastIndexOf('specification') + 13);
    const packageJson = JSON.parse(await fs_1.promises.readFile((0, path_1.join)(rootName, 'package.json'), 'utf8'));
    //shortens spec version
    const specVersion = packageJson.version.includes('+') ? packageJson.version.split('+')[0] : packageJson.version;
    const svgIcon = createSVGIcon(nameFloorPlan);
    const treeData = createTreeData(output, nameFloorPlan, odataVersion, specVersion);
    const templateFilePath = (0, path_1.join)(rootName, 'scripts', 'documentation', 'templateDocu.html');
    //only create html if porperties exist
    if (treeData.children.length > 0) {
        let template;
        try {
            template = await fs_1.promises.readFile(templateFilePath, 'utf8');
        }
        catch (e) {
            console.log(`Error: ${e.message}`);
            return;
        }
        template = template.replace(`'placeholderTreeData'`, JSON.stringify(treeData));
        template = template.replace(`OData_version`, odataVersion.toUpperCase());
        template = template.replace(`Spec_version`, specVersion);
        if (svgIcon !== undefined) {
            template = template.replace(`floorPlanIcon`, 'floorPlanIcon = `' + svgIcon + '`');
        }
        const outDir = odataVersion === 'v2' ? (0, path_1.join)('dist', 'documentation', 'v2') : (0, path_1.join)('dist', 'documentation', 'v4');
        try {
            await fs_1.promises.mkdir(outDir, { recursive: true });
        }
        catch (e) {
            // in case rare errors occur
            console.log(`Error: ${e.message}`);
            return;
        }
        const outFile = (0, path_1.join)(outDir, odataVersion + '-' + nameFloorPlan + '.html');
        await fs_1.promises.writeFile(outFile, template);
        console.log(`${outFile} was successfully saved!`);
    }
}
async function copyStyleSheetToDocFolder() {
    const file = 'styleDocu.css';
    const src = (0, path_1.join)(__dirname, '..', 'scripts', 'documentation', file);
    const outDir = (0, path_1.join)('dist', 'documentation');
    const dest = (0, path_1.join)(outDir, file);
    await fs_1.promises.mkdir(outDir, { recursive: true });
    try {
        // avoids EBUSY errors due to concurrent access
        await fs_1.promises.access(dest);
        console.log(file + ' already exists, skipping copy.');
    }
    catch {
        // file does not exist, proceed to copy
        await fs_1.promises.copyFile(src, dest);
        console.log(file + ' has been copied!');
    }
}
/**
 * Writes an Excel workbook to a file in the dist/documentation folder.
 *
 * @param workbook - Excel workbook (excel4node format)
 * @param version - OData version
 */
async function writeToFile(workbook, version) {
    const outDir = (0, path_1.join)('dist', 'documentation');
    await fs_1.promises.mkdir(outDir, { recursive: true });
    const outFile = (0, path_1.join)(outDir, 'Specification' + version + '.xlsx');
    workbook.write(outFile);
}
/**
 * Reads a schema file, parses its contents, and builds the output array.
 *
 * @param directoryPath - The directory containing the schema files.
 * @param file - The name of the schema file to process.
 * @returns An object containing the parsed output array and the file name.
 */
async function getParsedOutput(directoryPath, file) {
    const filePath = (0, path_1.join)(directoryPath, file);
    const output = [filePath];
    const data = await fs_1.promises.readFile(filePath, 'utf8');
    const schema = JSON.parse(data);
    parseSchema(schema, schema, output);
    return { output, file };
}
/********************** Main ***************************/
async function generateDocumentation() {
    const myArgs = process.argv.slice(2);
    let version;
    let format;
    myArgs.forEach((arg) => {
        const value = arg.split('=')[1];
        if (arg.includes('version')) {
            version = value;
        }
        else if (arg.includes('format')) {
            format = value;
        }
    });
    let directoryPath = '';
    switch (version) {
        case ux_specification_types_1.FioriElementsVersion.v2:
            directoryPath = (0, path_1.join)('schemas', 'v2');
            break;
        case ux_specification_types_1.FioriElementsVersion.v4:
            directoryPath = (0, path_1.join)('schemas', 'v4');
            break;
        default:
            console.log('Invalid version ' + version + '; processing stopped.');
            break;
    }
    if (directoryPath.length > 0) {
        const workbook = new excel.Workbook();
        try {
            const files = await fs_1.promises.readdir(directoryPath);
            if (format === 'excel') {
                for (const file of files) {
                    const { output, file: fileName } = await getParsedOutput(directoryPath, file);
                    writeToExcel(workbook, output, fileName);
                }
                await writeToFile(workbook, version);
            }
            else if (format === 'html') {
                await Promise.all(files.map(async (file) => {
                    const { output, file: fileName } = await getParsedOutput(directoryPath, file);
                    await generateHTMLFormat(output, fileName, version);
                }));
                await copyStyleSheetToDocFolder();
            }
        }
        catch (err) {
            console.log(err);
        }
    }
}
(async () => {
    await generateDocumentation();
})();
//# sourceMappingURL=extractDocu.js.map